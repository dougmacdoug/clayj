// Generated by jextract

package dmacd.ffm.raylib;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.util.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;

public class RayFFM {

    RayFFM() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.loaderLookup()
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfDouble C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;
    private static final int FLAG_VSYNC_HINT = (int)64L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_VSYNC_HINT = 64
     * }
     */
    public static int FLAG_VSYNC_HINT() {
        return FLAG_VSYNC_HINT;
    }
    private static final int FLAG_FULLSCREEN_MODE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_FULLSCREEN_MODE = 2
     * }
     */
    public static int FLAG_FULLSCREEN_MODE() {
        return FLAG_FULLSCREEN_MODE;
    }
    private static final int FLAG_WINDOW_RESIZABLE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_RESIZABLE = 4
     * }
     */
    public static int FLAG_WINDOW_RESIZABLE() {
        return FLAG_WINDOW_RESIZABLE;
    }
    private static final int FLAG_WINDOW_UNDECORATED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_UNDECORATED = 8
     * }
     */
    public static int FLAG_WINDOW_UNDECORATED() {
        return FLAG_WINDOW_UNDECORATED;
    }
    private static final int FLAG_WINDOW_HIDDEN = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_HIDDEN = 128
     * }
     */
    public static int FLAG_WINDOW_HIDDEN() {
        return FLAG_WINDOW_HIDDEN;
    }
    private static final int FLAG_WINDOW_MINIMIZED = (int)512L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_MINIMIZED = 512
     * }
     */
    public static int FLAG_WINDOW_MINIMIZED() {
        return FLAG_WINDOW_MINIMIZED;
    }
    private static final int FLAG_WINDOW_MAXIMIZED = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_MAXIMIZED = 1024
     * }
     */
    public static int FLAG_WINDOW_MAXIMIZED() {
        return FLAG_WINDOW_MAXIMIZED;
    }
    private static final int FLAG_WINDOW_UNFOCUSED = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_UNFOCUSED = 2048
     * }
     */
    public static int FLAG_WINDOW_UNFOCUSED() {
        return FLAG_WINDOW_UNFOCUSED;
    }
    private static final int FLAG_WINDOW_TOPMOST = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_TOPMOST = 4096
     * }
     */
    public static int FLAG_WINDOW_TOPMOST() {
        return FLAG_WINDOW_TOPMOST;
    }
    private static final int FLAG_WINDOW_ALWAYS_RUN = (int)256L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_ALWAYS_RUN = 256
     * }
     */
    public static int FLAG_WINDOW_ALWAYS_RUN() {
        return FLAG_WINDOW_ALWAYS_RUN;
    }
    private static final int FLAG_WINDOW_TRANSPARENT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_TRANSPARENT = 16
     * }
     */
    public static int FLAG_WINDOW_TRANSPARENT() {
        return FLAG_WINDOW_TRANSPARENT;
    }
    private static final int FLAG_WINDOW_HIGHDPI = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_HIGHDPI = 8192
     * }
     */
    public static int FLAG_WINDOW_HIGHDPI() {
        return FLAG_WINDOW_HIGHDPI;
    }
    private static final int FLAG_WINDOW_MOUSE_PASSTHROUGH = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_WINDOW_MOUSE_PASSTHROUGH = 16384
     * }
     */
    public static int FLAG_WINDOW_MOUSE_PASSTHROUGH() {
        return FLAG_WINDOW_MOUSE_PASSTHROUGH;
    }
    private static final int FLAG_BORDERLESS_WINDOWED_MODE = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_BORDERLESS_WINDOWED_MODE = 32768
     * }
     */
    public static int FLAG_BORDERLESS_WINDOWED_MODE() {
        return FLAG_BORDERLESS_WINDOWED_MODE;
    }
    private static final int FLAG_MSAA_4X_HINT = (int)32L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_MSAA_4X_HINT = 32
     * }
     */
    public static int FLAG_MSAA_4X_HINT() {
        return FLAG_MSAA_4X_HINT;
    }
    private static final int FLAG_INTERLACED_HINT = (int)65536L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FLAG_INTERLACED_HINT = 65536
     * }
     */
    public static int FLAG_INTERLACED_HINT() {
        return FLAG_INTERLACED_HINT;
    }
    private static final int TEXTURE_FILTER_POINT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTURE_FILTER_POINT = 0
     * }
     */
    public static int TEXTURE_FILTER_POINT() {
        return TEXTURE_FILTER_POINT;
    }
    private static final int TEXTURE_FILTER_BILINEAR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTURE_FILTER_BILINEAR = 1
     * }
     */
    public static int TEXTURE_FILTER_BILINEAR() {
        return TEXTURE_FILTER_BILINEAR;
    }
    private static final int TEXTURE_FILTER_TRILINEAR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTURE_FILTER_TRILINEAR = 2
     * }
     */
    public static int TEXTURE_FILTER_TRILINEAR() {
        return TEXTURE_FILTER_TRILINEAR;
    }
    private static final int TEXTURE_FILTER_ANISOTROPIC_4X = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTURE_FILTER_ANISOTROPIC_4X = 3
     * }
     */
    public static int TEXTURE_FILTER_ANISOTROPIC_4X() {
        return TEXTURE_FILTER_ANISOTROPIC_4X;
    }
    private static final int TEXTURE_FILTER_ANISOTROPIC_8X = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTURE_FILTER_ANISOTROPIC_8X = 4
     * }
     */
    public static int TEXTURE_FILTER_ANISOTROPIC_8X() {
        return TEXTURE_FILTER_ANISOTROPIC_8X;
    }
    private static final int TEXTURE_FILTER_ANISOTROPIC_16X = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TEXTURE_FILTER_ANISOTROPIC_16X = 5
     * }
     */
    public static int TEXTURE_FILTER_ANISOTROPIC_16X() {
        return TEXTURE_FILTER_ANISOTROPIC_16X;
    }
    private static final int FONT_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FONT_DEFAULT = 0
     * }
     */
    public static int FONT_DEFAULT() {
        return FONT_DEFAULT;
    }
    private static final int FONT_BITMAP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.FONT_BITMAP = 1
     * }
     */
    public static int FONT_BITMAP() {
        return FONT_BITMAP;
    }
    private static final int CAMERA_PERSPECTIVE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CAMERA_PERSPECTIVE = 0
     * }
     */
    public static int CAMERA_PERSPECTIVE() {
        return CAMERA_PERSPECTIVE;
    }
    private static final int CAMERA_ORTHOGRAPHIC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.CAMERA_ORTHOGRAPHIC = 1
     * }
     */
    public static int CAMERA_ORTHOGRAPHIC() {
        return CAMERA_ORTHOGRAPHIC;
    }

    private static class InitWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            RayFFM.C_INT,
            RayFFM.C_INT,
            RayFFM.C_POINTER
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("InitWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitWindow(int width, int height, const char *title)
     * }
     */
    public static FunctionDescriptor InitWindow$descriptor() {
        return InitWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitWindow(int width, int height, const char *title)
     * }
     */
    public static MethodHandle InitWindow$handle() {
        return InitWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void InitWindow(int width, int height, const char *title)
     * }
     */
    public static MemorySegment InitWindow$address() {
        return InitWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void InitWindow(int width, int height, const char *title)
     * }
     */
    public static void InitWindow(int width, int height, MemorySegment title) {
        var mh$ = InitWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitWindow", width, height, title);
            }
            mh$.invokeExact(width, height, title);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("CloseWindow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseWindow()
     * }
     */
    public static FunctionDescriptor CloseWindow$descriptor() {
        return CloseWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseWindow()
     * }
     */
    public static MethodHandle CloseWindow$handle() {
        return CloseWindow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CloseWindow()
     * }
     */
    public static MemorySegment CloseWindow$address() {
        return CloseWindow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CloseWindow()
     * }
     */
    public static void CloseWindow() {
        var mh$ = CloseWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseWindow");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WindowShouldClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RayFFM.C_BOOL    );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("WindowShouldClose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool WindowShouldClose()
     * }
     */
    public static FunctionDescriptor WindowShouldClose$descriptor() {
        return WindowShouldClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool WindowShouldClose()
     * }
     */
    public static MethodHandle WindowShouldClose$handle() {
        return WindowShouldClose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool WindowShouldClose()
     * }
     */
    public static MemorySegment WindowShouldClose$address() {
        return WindowShouldClose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool WindowShouldClose()
     * }
     */
    public static boolean WindowShouldClose() {
        var mh$ = WindowShouldClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WindowShouldClose");
            }
            return (boolean)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetScreenWidth {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RayFFM.C_INT    );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("GetScreenWidth");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetScreenWidth()
     * }
     */
    public static FunctionDescriptor GetScreenWidth$descriptor() {
        return GetScreenWidth.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetScreenWidth()
     * }
     */
    public static MethodHandle GetScreenWidth$handle() {
        return GetScreenWidth.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetScreenWidth()
     * }
     */
    public static MemorySegment GetScreenWidth$address() {
        return GetScreenWidth.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetScreenWidth()
     * }
     */
    public static int GetScreenWidth() {
        var mh$ = GetScreenWidth.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetScreenWidth");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetScreenHeight {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RayFFM.C_INT    );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("GetScreenHeight");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetScreenHeight()
     * }
     */
    public static FunctionDescriptor GetScreenHeight$descriptor() {
        return GetScreenHeight.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetScreenHeight()
     * }
     */
    public static MethodHandle GetScreenHeight$handle() {
        return GetScreenHeight.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GetScreenHeight()
     * }
     */
    public static MemorySegment GetScreenHeight$address() {
        return GetScreenHeight.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GetScreenHeight()
     * }
     */
    public static int GetScreenHeight() {
        var mh$ = GetScreenHeight.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetScreenHeight");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClearBackground {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Rayliib.Color.layout()
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("ClearBackground");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ClearBackground(Color color)
     * }
     */
    public static FunctionDescriptor ClearBackground$descriptor() {
        return ClearBackground.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ClearBackground(Color color)
     * }
     */
    public static MethodHandle ClearBackground$handle() {
        return ClearBackground.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ClearBackground(Color color)
     * }
     */
    public static MemorySegment ClearBackground$address() {
        return ClearBackground.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ClearBackground(Color color)
     * }
     */
    public static void ClearBackground(MemorySegment color) {
        var mh$ = ClearBackground.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearBackground", color);
            }
            mh$.invokeExact(color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginDrawing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("BeginDrawing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BeginDrawing()
     * }
     */
    public static FunctionDescriptor BeginDrawing$descriptor() {
        return BeginDrawing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BeginDrawing()
     * }
     */
    public static MethodHandle BeginDrawing$handle() {
        return BeginDrawing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BeginDrawing()
     * }
     */
    public static MemorySegment BeginDrawing$address() {
        return BeginDrawing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BeginDrawing()
     * }
     */
    public static void BeginDrawing() {
        var mh$ = BeginDrawing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginDrawing");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndDrawing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("EndDrawing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void EndDrawing()
     * }
     */
    public static FunctionDescriptor EndDrawing$descriptor() {
        return EndDrawing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void EndDrawing()
     * }
     */
    public static MethodHandle EndDrawing$handle() {
        return EndDrawing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void EndDrawing()
     * }
     */
    public static MemorySegment EndDrawing$address() {
        return EndDrawing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void EndDrawing()
     * }
     */
    public static void EndDrawing() {
        var mh$ = EndDrawing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndDrawing");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginScissorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            RayFFM.C_INT,
            RayFFM.C_INT,
            RayFFM.C_INT,
            RayFFM.C_INT
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("BeginScissorMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BeginScissorMode(int x, int y, int width, int height)
     * }
     */
    public static FunctionDescriptor BeginScissorMode$descriptor() {
        return BeginScissorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BeginScissorMode(int x, int y, int width, int height)
     * }
     */
    public static MethodHandle BeginScissorMode$handle() {
        return BeginScissorMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BeginScissorMode(int x, int y, int width, int height)
     * }
     */
    public static MemorySegment BeginScissorMode$address() {
        return BeginScissorMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BeginScissorMode(int x, int y, int width, int height)
     * }
     */
    public static void BeginScissorMode(int x, int y, int width, int height) {
        var mh$ = BeginScissorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginScissorMode", x, y, width, height);
            }
            mh$.invokeExact(x, y, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndScissorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("EndScissorMode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void EndScissorMode()
     * }
     */
    public static FunctionDescriptor EndScissorMode$descriptor() {
        return EndScissorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void EndScissorMode()
     * }
     */
    public static MethodHandle EndScissorMode$handle() {
        return EndScissorMode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void EndScissorMode()
     * }
     */
    public static MemorySegment EndScissorMode$address() {
        return EndScissorMode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void EndScissorMode()
     * }
     */
    public static void EndScissorMode() {
        var mh$ = EndScissorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndScissorMode");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTargetFPS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            RayFFM.C_INT
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("SetTargetFPS");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetTargetFPS(int fps)
     * }
     */
    public static FunctionDescriptor SetTargetFPS$descriptor() {
        return SetTargetFPS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetTargetFPS(int fps)
     * }
     */
    public static MethodHandle SetTargetFPS$handle() {
        return SetTargetFPS.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetTargetFPS(int fps)
     * }
     */
    public static MemorySegment SetTargetFPS$address() {
        return SetTargetFPS.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetTargetFPS(int fps)
     * }
     */
    public static void SetTargetFPS(int fps) {
        var mh$ = SetTargetFPS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTargetFPS", fps);
            }
            mh$.invokeExact(fps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFrameTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RayFFM.C_FLOAT    );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("GetFrameTime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float GetFrameTime()
     * }
     */
    public static FunctionDescriptor GetFrameTime$descriptor() {
        return GetFrameTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float GetFrameTime()
     * }
     */
    public static MethodHandle GetFrameTime$handle() {
        return GetFrameTime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float GetFrameTime()
     * }
     */
    public static MemorySegment GetFrameTime$address() {
        return GetFrameTime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float GetFrameTime()
     * }
     */
    public static float GetFrameTime() {
        var mh$ = GetFrameTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFrameTime");
            }
            return (float)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConfigFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            RayFFM.C_INT
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("SetConfigFlags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetConfigFlags(unsigned int flags)
     * }
     */
    public static FunctionDescriptor SetConfigFlags$descriptor() {
        return SetConfigFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetConfigFlags(unsigned int flags)
     * }
     */
    public static MethodHandle SetConfigFlags$handle() {
        return SetConfigFlags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetConfigFlags(unsigned int flags)
     * }
     */
    public static MemorySegment SetConfigFlags$address() {
        return SetConfigFlags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetConfigFlags(unsigned int flags)
     * }
     */
    public static void SetConfigFlags(int flags) {
        var mh$ = SetConfigFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConfigFlags", flags);
            }
            mh$.invokeExact(flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMouseButtonDown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RayFFM.C_BOOL,
            RayFFM.C_INT
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("IsMouseButtonDown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _Bool IsMouseButtonDown(int button)
     * }
     */
    public static FunctionDescriptor IsMouseButtonDown$descriptor() {
        return IsMouseButtonDown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _Bool IsMouseButtonDown(int button)
     * }
     */
    public static MethodHandle IsMouseButtonDown$handle() {
        return IsMouseButtonDown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * _Bool IsMouseButtonDown(int button)
     * }
     */
    public static MemorySegment IsMouseButtonDown$address() {
        return IsMouseButtonDown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * _Bool IsMouseButtonDown(int button)
     * }
     */
    public static boolean IsMouseButtonDown(int button) {
        var mh$ = IsMouseButtonDown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMouseButtonDown", button);
            }
            return (boolean)mh$.invokeExact(button);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMousePosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rayliib.Vector2.layout()    );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("GetMousePosition");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetMousePosition()
     * }
     */
    public static FunctionDescriptor GetMousePosition$descriptor() {
        return GetMousePosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetMousePosition()
     * }
     */
    public static MethodHandle GetMousePosition$handle() {
        return GetMousePosition.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetMousePosition()
     * }
     */
    public static MemorySegment GetMousePosition$address() {
        return GetMousePosition.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetMousePosition()
     * }
     */
    public static MemorySegment GetMousePosition(SegmentAllocator allocator) {
        var mh$ = GetMousePosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMousePosition", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMouseWheelMoveV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rayliib.Vector2.layout()    );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("GetMouseWheelMoveV");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector2 GetMouseWheelMoveV()
     * }
     */
    public static FunctionDescriptor GetMouseWheelMoveV$descriptor() {
        return GetMouseWheelMoveV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector2 GetMouseWheelMoveV()
     * }
     */
    public static MethodHandle GetMouseWheelMoveV$handle() {
        return GetMouseWheelMoveV.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector2 GetMouseWheelMoveV()
     * }
     */
    public static MemorySegment GetMouseWheelMoveV$address() {
        return GetMouseWheelMoveV.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector2 GetMouseWheelMoveV()
     * }
     */
    public static MemorySegment GetMouseWheelMoveV(SegmentAllocator allocator) {
        var mh$ = GetMouseWheelMoveV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMouseWheelMoveV", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRing {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Rayliib.Vector2.layout(),
            RayFFM.C_FLOAT,
            RayFFM.C_FLOAT,
            RayFFM.C_FLOAT,
            RayFFM.C_FLOAT,
            RayFFM.C_INT,
            Rayliib.Color.layout()
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("DrawRing");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRing(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static FunctionDescriptor DrawRing$descriptor() {
        return DrawRing.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRing(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static MethodHandle DrawRing$handle() {
        return DrawRing.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRing(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static MemorySegment DrawRing$address() {
        return DrawRing.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRing(Vector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, Color color)
     * }
     */
    public static void DrawRing(MemorySegment center, float innerRadius, float outerRadius, float startAngle, float endAngle, int segments, MemorySegment color) {
        var mh$ = DrawRing.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRing", center, innerRadius, outerRadius, startAngle, endAngle, segments, color);
            }
            mh$.invokeExact(center, innerRadius, outerRadius, startAngle, endAngle, segments, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            RayFFM.C_INT,
            RayFFM.C_INT,
            RayFFM.C_INT,
            RayFFM.C_INT,
            Rayliib.Color.layout()
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("DrawRectangle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRectangle(int posX, int posY, int width, int height, Color color)
     * }
     */
    public static FunctionDescriptor DrawRectangle$descriptor() {
        return DrawRectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRectangle(int posX, int posY, int width, int height, Color color)
     * }
     */
    public static MethodHandle DrawRectangle$handle() {
        return DrawRectangle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRectangle(int posX, int posY, int width, int height, Color color)
     * }
     */
    public static MemorySegment DrawRectangle$address() {
        return DrawRectangle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRectangle(int posX, int posY, int width, int height, Color color)
     * }
     */
    public static void DrawRectangle(int posX, int posY, int width, int height, MemorySegment color) {
        var mh$ = DrawRectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRectangle", posX, posY, width, height, color);
            }
            mh$.invokeExact(posX, posY, width, height, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawRectangleRounded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Rayliib.Rectangle.layout(),
            RayFFM.C_FLOAT,
            RayFFM.C_INT,
            Rayliib.Color.layout()
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("DrawRectangleRounded");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawRectangleRounded(Rectangle rec, float roundness, int segments, Color color)
     * }
     */
    public static FunctionDescriptor DrawRectangleRounded$descriptor() {
        return DrawRectangleRounded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawRectangleRounded(Rectangle rec, float roundness, int segments, Color color)
     * }
     */
    public static MethodHandle DrawRectangleRounded$handle() {
        return DrawRectangleRounded.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawRectangleRounded(Rectangle rec, float roundness, int segments, Color color)
     * }
     */
    public static MemorySegment DrawRectangleRounded$address() {
        return DrawRectangleRounded.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawRectangleRounded(Rectangle rec, float roundness, int segments, Color color)
     * }
     */
    public static void DrawRectangleRounded(MemorySegment rec, float roundness, int segments, MemorySegment color) {
        var mh$ = DrawRectangleRounded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawRectangleRounded", rec, roundness, segments, color);
            }
            mh$.invokeExact(rec, roundness, segments, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rayliib.Image.layout(),
            RayFFM.C_POINTER
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("LoadImage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Image LoadImage(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadImage$descriptor() {
        return LoadImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Image LoadImage(const char *fileName)
     * }
     */
    public static MethodHandle LoadImage$handle() {
        return LoadImage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Image LoadImage(const char *fileName)
     * }
     */
    public static MemorySegment LoadImage$address() {
        return LoadImage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Image LoadImage(const char *fileName)
     * }
     */
    public static MemorySegment LoadImage(SegmentAllocator allocator, MemorySegment fileName) {
        var mh$ = LoadImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadImage", allocator, fileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextureFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Rayliib.Texture.layout(),
            RayFFM.C_INT
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("SetTextureFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetTextureFilter(Texture2D texture, int filter)
     * }
     */
    public static FunctionDescriptor SetTextureFilter$descriptor() {
        return SetTextureFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetTextureFilter(Texture2D texture, int filter)
     * }
     */
    public static MethodHandle SetTextureFilter$handle() {
        return SetTextureFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SetTextureFilter(Texture2D texture, int filter)
     * }
     */
    public static MemorySegment SetTextureFilter$address() {
        return SetTextureFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SetTextureFilter(Texture2D texture, int filter)
     * }
     */
    public static void SetTextureFilter(MemorySegment texture, int filter) {
        var mh$ = SetTextureFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextureFilter", texture, filter);
            }
            mh$.invokeExact(texture, filter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Rayliib.Texture.layout(),
            RayFFM.C_INT,
            RayFFM.C_INT,
            Rayliib.Color.layout()
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("DrawTexture");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTexture(Texture2D texture, int posX, int posY, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTexture$descriptor() {
        return DrawTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTexture(Texture2D texture, int posX, int posY, Color tint)
     * }
     */
    public static MethodHandle DrawTexture$handle() {
        return DrawTexture.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTexture(Texture2D texture, int posX, int posY, Color tint)
     * }
     */
    public static MemorySegment DrawTexture$address() {
        return DrawTexture.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTexture(Texture2D texture, int posX, int posY, Color tint)
     * }
     */
    public static void DrawTexture(MemorySegment texture, int posX, int posY, MemorySegment tint) {
        var mh$ = DrawTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTexture", texture, posX, posY, tint);
            }
            mh$.invokeExact(texture, posX, posY, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTexturePro {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Rayliib.Texture.layout(),
            Rayliib.Rectangle.layout(),
            Rayliib.Rectangle.layout(),
            Rayliib.Vector2.layout(),
            RayFFM.C_FLOAT,
            Rayliib.Color.layout()
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("DrawTexturePro");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTexturePro$descriptor() {
        return DrawTexturePro.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static MethodHandle DrawTexturePro$handle() {
        return DrawTexturePro.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static MemorySegment DrawTexturePro$address() {
        return DrawTexturePro.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint)
     * }
     */
    public static void DrawTexturePro(MemorySegment texture, MemorySegment source, MemorySegment dest, MemorySegment origin, float rotation, MemorySegment tint) {
        var mh$ = DrawTexturePro.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTexturePro", texture, source, dest, origin, rotation, tint);
            }
            mh$.invokeExact(texture, source, dest, origin, rotation, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFontDefault {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rayliib.Font.layout()    );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("GetFontDefault");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Font GetFontDefault()
     * }
     */
    public static FunctionDescriptor GetFontDefault$descriptor() {
        return GetFontDefault.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Font GetFontDefault()
     * }
     */
    public static MethodHandle GetFontDefault$handle() {
        return GetFontDefault.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Font GetFontDefault()
     * }
     */
    public static MemorySegment GetFontDefault$address() {
        return GetFontDefault.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Font GetFontDefault()
     * }
     */
    public static MemorySegment GetFontDefault(SegmentAllocator allocator) {
        var mh$ = GetFontDefault.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFontDefault", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rayliib.Font.layout(),
            RayFFM.C_POINTER
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("LoadFont");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Font LoadFont(const char *fileName)
     * }
     */
    public static FunctionDescriptor LoadFont$descriptor() {
        return LoadFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Font LoadFont(const char *fileName)
     * }
     */
    public static MethodHandle LoadFont$handle() {
        return LoadFont.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Font LoadFont(const char *fileName)
     * }
     */
    public static MemorySegment LoadFont$address() {
        return LoadFont.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Font LoadFont(const char *fileName)
     * }
     */
    public static MemorySegment LoadFont(SegmentAllocator allocator, MemorySegment fileName) {
        var mh$ = LoadFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadFont", allocator, fileName);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadFontEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rayliib.Font.layout(),
            RayFFM.C_POINTER,
            RayFFM.C_INT,
            RayFFM.C_POINTER,
            RayFFM.C_INT
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("LoadFontEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Font LoadFontEx(const char *fileName, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static FunctionDescriptor LoadFontEx$descriptor() {
        return LoadFontEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Font LoadFontEx(const char *fileName, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static MethodHandle LoadFontEx$handle() {
        return LoadFontEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Font LoadFontEx(const char *fileName, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static MemorySegment LoadFontEx$address() {
        return LoadFontEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Font LoadFontEx(const char *fileName, int fontSize, int *codepoints, int codepointCount)
     * }
     */
    public static MemorySegment LoadFontEx(SegmentAllocator allocator, MemorySegment fileName, int fontSize, MemorySegment codepoints, int codepointCount) {
        var mh$ = LoadFontEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadFontEx", allocator, fileName, fontSize, codepoints, codepointCount);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fileName, fontSize, codepoints, codepointCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            RayFFM.C_POINTER,
            RayFFM.C_INT,
            RayFFM.C_INT,
            RayFFM.C_INT,
            Rayliib.Color.layout()
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("DrawText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawText(const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static FunctionDescriptor DrawText$descriptor() {
        return DrawText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawText(const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static MethodHandle DrawText$handle() {
        return DrawText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawText(const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static MemorySegment DrawText$address() {
        return DrawText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawText(const char *text, int posX, int posY, int fontSize, Color color)
     * }
     */
    public static void DrawText(MemorySegment text, int posX, int posY, int fontSize, MemorySegment color) {
        var mh$ = DrawText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawText", text, posX, posY, fontSize, color);
            }
            mh$.invokeExact(text, posX, posY, fontSize, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            Rayliib.Font.layout(),
            RayFFM.C_POINTER,
            Rayliib.Vector2.layout(),
            RayFFM.C_FLOAT,
            RayFFM.C_FLOAT,
            Rayliib.Color.layout()
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("DrawTextEx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static FunctionDescriptor DrawTextEx$descriptor() {
        return DrawTextEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static MethodHandle DrawTextEx$handle() {
        return DrawTextEx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static MemorySegment DrawTextEx$address() {
        return DrawTextEx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrawTextEx(Font font, const char *text, Vector2 position, float fontSize, float spacing, Color tint)
     * }
     */
    public static void DrawTextEx(MemorySegment font, MemorySegment text, MemorySegment position, float fontSize, float spacing, MemorySegment tint) {
        var mh$ = DrawTextEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextEx", font, text, position, fontSize, spacing, tint);
            }
            mh$.invokeExact(font, text, position, fontSize, spacing, tint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MeasureText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            RayFFM.C_INT,
            RayFFM.C_POINTER,
            RayFFM.C_INT
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("MeasureText");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MeasureText(const char *text, int fontSize)
     * }
     */
    public static FunctionDescriptor MeasureText$descriptor() {
        return MeasureText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MeasureText(const char *text, int fontSize)
     * }
     */
    public static MethodHandle MeasureText$handle() {
        return MeasureText.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MeasureText(const char *text, int fontSize)
     * }
     */
    public static MemorySegment MeasureText$address() {
        return MeasureText.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MeasureText(const char *text, int fontSize)
     * }
     */
    public static int MeasureText(MemorySegment text, int fontSize) {
        var mh$ = MeasureText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MeasureText", text, fontSize);
            }
            return (int)mh$.invokeExact(text, fontSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixLookAt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rayliib.Matrix.layout(),
            Rayliib.Vector3.layout(),
            Rayliib.Vector3.layout(),
            Rayliib.Vector3.layout()
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("MatrixLookAt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixLookAt(Vector3 eye, Vector3 target, Vector3 up)
     * }
     */
    public static FunctionDescriptor MatrixLookAt$descriptor() {
        return MatrixLookAt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixLookAt(Vector3 eye, Vector3 target, Vector3 up)
     * }
     */
    public static MethodHandle MatrixLookAt$handle() {
        return MatrixLookAt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixLookAt(Vector3 eye, Vector3 target, Vector3 up)
     * }
     */
    public static MemorySegment MatrixLookAt$address() {
        return MatrixLookAt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixLookAt(Vector3 eye, Vector3 target, Vector3 up)
     * }
     */
    public static MemorySegment MatrixLookAt(SegmentAllocator allocator, MemorySegment eye, MemorySegment target, MemorySegment up) {
        var mh$ = MatrixLookAt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixLookAt", allocator, eye, target, up);
            }
            return (MemorySegment)mh$.invokeExact(allocator, eye, target, up);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixIdentity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rayliib.Matrix.layout()    );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("MatrixIdentity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixIdentity()
     * }
     */
    public static FunctionDescriptor MatrixIdentity$descriptor() {
        return MatrixIdentity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixIdentity()
     * }
     */
    public static MethodHandle MatrixIdentity$handle() {
        return MatrixIdentity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixIdentity()
     * }
     */
    public static MemorySegment MatrixIdentity$address() {
        return MatrixIdentity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixIdentity()
     * }
     */
    public static MemorySegment MatrixIdentity(SegmentAllocator allocator) {
        var mh$ = MatrixIdentity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixIdentity", allocator);
            }
            return (MemorySegment)mh$.invokeExact(allocator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixPerspective {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rayliib.Matrix.layout(),
            RayFFM.C_DOUBLE,
            RayFFM.C_DOUBLE,
            RayFFM.C_DOUBLE,
            RayFFM.C_DOUBLE
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("MatrixPerspective");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixPerspective(double fovY, double aspect, double nearPlane, double farPlane)
     * }
     */
    public static FunctionDescriptor MatrixPerspective$descriptor() {
        return MatrixPerspective.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixPerspective(double fovY, double aspect, double nearPlane, double farPlane)
     * }
     */
    public static MethodHandle MatrixPerspective$handle() {
        return MatrixPerspective.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixPerspective(double fovY, double aspect, double nearPlane, double farPlane)
     * }
     */
    public static MemorySegment MatrixPerspective$address() {
        return MatrixPerspective.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixPerspective(double fovY, double aspect, double nearPlane, double farPlane)
     * }
     */
    public static MemorySegment MatrixPerspective(SegmentAllocator allocator, double fovY, double aspect, double nearPlane, double farPlane) {
        var mh$ = MatrixPerspective.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixPerspective", allocator, fovY, aspect, nearPlane, farPlane);
            }
            return (MemorySegment)mh$.invokeExact(allocator, fovY, aspect, nearPlane, farPlane);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MatrixOrtho {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rayliib.Matrix.layout(),
            RayFFM.C_DOUBLE,
            RayFFM.C_DOUBLE,
            RayFFM.C_DOUBLE,
            RayFFM.C_DOUBLE,
            RayFFM.C_DOUBLE,
            RayFFM.C_DOUBLE
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("MatrixOrtho");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Matrix MatrixOrtho(double left, double right, double bottom, double top, double nearPlane, double farPlane)
     * }
     */
    public static FunctionDescriptor MatrixOrtho$descriptor() {
        return MatrixOrtho.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Matrix MatrixOrtho(double left, double right, double bottom, double top, double nearPlane, double farPlane)
     * }
     */
    public static MethodHandle MatrixOrtho$handle() {
        return MatrixOrtho.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Matrix MatrixOrtho(double left, double right, double bottom, double top, double nearPlane, double farPlane)
     * }
     */
    public static MemorySegment MatrixOrtho$address() {
        return MatrixOrtho.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Matrix MatrixOrtho(double left, double right, double bottom, double top, double nearPlane, double farPlane)
     * }
     */
    public static MemorySegment MatrixOrtho(SegmentAllocator allocator, double left, double right, double bottom, double top, double nearPlane, double farPlane) {
        var mh$ = MatrixOrtho.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MatrixOrtho", allocator, left, right, bottom, top, nearPlane, farPlane);
            }
            return (MemorySegment)mh$.invokeExact(allocator, left, right, bottom, top, nearPlane, farPlane);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Unproject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rayliib.Vector3.layout(),
            Rayliib.Vector3.layout(),
            Rayliib.Matrix.layout(),
            Rayliib.Matrix.layout()
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("Vector3Unproject");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Unproject(Vector3 source, Matrix projection, Matrix view)
     * }
     */
    public static FunctionDescriptor Vector3Unproject$descriptor() {
        return Vector3Unproject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Unproject(Vector3 source, Matrix projection, Matrix view)
     * }
     */
    public static MethodHandle Vector3Unproject$handle() {
        return Vector3Unproject.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Unproject(Vector3 source, Matrix projection, Matrix view)
     * }
     */
    public static MemorySegment Vector3Unproject$address() {
        return Vector3Unproject.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Unproject(Vector3 source, Matrix projection, Matrix view)
     * }
     */
    public static MemorySegment Vector3Unproject(SegmentAllocator allocator, MemorySegment source, MemorySegment projection, MemorySegment view) {
        var mh$ = Vector3Unproject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Unproject", allocator, source, projection, view);
            }
            return (MemorySegment)mh$.invokeExact(allocator, source, projection, view);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Normalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rayliib.Vector3.layout(),
            Rayliib.Vector3.layout()
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("Vector3Normalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Normalize(Vector3 v)
     * }
     */
    public static FunctionDescriptor Vector3Normalize$descriptor() {
        return Vector3Normalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Normalize(Vector3 v)
     * }
     */
    public static MethodHandle Vector3Normalize$handle() {
        return Vector3Normalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Normalize(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Normalize$address() {
        return Vector3Normalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Normalize(Vector3 v)
     * }
     */
    public static MemorySegment Vector3Normalize(SegmentAllocator allocator, MemorySegment v) {
        var mh$ = Vector3Normalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Normalize", allocator, v);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Vector3Subtract {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            Rayliib.Vector3.layout(),
            Rayliib.Vector3.layout(),
            Rayliib.Vector3.layout()
        );

        public static final MemorySegment ADDR = RayFFM.findOrThrow("Vector3Subtract");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * Vector3 Vector3Subtract(Vector3 v1, Vector3 v2)
     * }
     */
    public static FunctionDescriptor Vector3Subtract$descriptor() {
        return Vector3Subtract.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * Vector3 Vector3Subtract(Vector3 v1, Vector3 v2)
     * }
     */
    public static MethodHandle Vector3Subtract$handle() {
        return Vector3Subtract.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * Vector3 Vector3Subtract(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Subtract$address() {
        return Vector3Subtract.ADDR;
    }

    /**
     * {@snippet lang=c :
     * Vector3 Vector3Subtract(Vector3 v1, Vector3 v2)
     * }
     */
    public static MemorySegment Vector3Subtract(SegmentAllocator allocator, MemorySegment v1, MemorySegment v2) {
        var mh$ = Vector3Subtract.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Vector3Subtract", allocator, v1, v2);
            }
            return (MemorySegment)mh$.invokeExact(allocator, v1, v2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final float DEG2RAD = 0.01745329238474369f;
    /**
     * {@snippet lang=c :
     * #define DEG2RAD 0.01745329238474369
     * }
     */
    public static float DEG2RAD() {
        return DEG2RAD;
    }
}

